### [[2.4: Systemic Thinking]]

I'll use "Systemic Thinking" to mean thinking in a way where everything is inside of a system.  Systemic Thinking focuses on the relationships between all things in a system, and their mechanical relationships to each other.  A system being a set of things you wish to model, to accomplish one or more goals by using the model to understanding mechanically what the effects of a planned action would be.  

The Model gives feedback about what the current state of the set of Components are, and what the likely state of the Set of Components will be if an action were to be performed.  This also works in reverse to provide information about what happened in the past, by comparing Data to the Model, which can both improve the Model by correcting it against Data and Reality, and give information by inspecting the Data produced by Reality, and using the Model to explain that Data.

A System can be described by a network of black box functions which take inputs, emit outputs, and perform side-effects, totaling the results of anything that exists or doesn't exist, Real or Virtual.  Either way, it can be described as a System, and using this methodology for organizing one's thoughts is "Systemic Thinking" by my definition here.

I believe Systemic Thinking is one of the most powerful and useful tools in our mental toolbox, and could use a lot more of the educational spotlight.  In terms of yielding positive results in learning speed and depth, creating works, and in performing maintenance (ie. troubleshooting), Systemic Thinking is among the most useful tools.

Systemic Thinking has a number of prerequisites, such as a general understanding of how systems work, how to create systems, how to modify a system, how to inspect and evaluate the connections and links between system components, and a good basis in critical thinking.  Having the ability to think deductively and inductively is a fundamental requirement.

If you have not yet read a book on critical thinking, you should, to ensure you have the basic understanding of the topic.  Of course you can fill in this information later now that you know it's something that could benefit you.  

{{ asside_begin }}
There is an infinite amount of information that is possible to learn, so the important thing is to bookmark all new "requirements" for the future, and follow up on what is most useful for the current goal to be accomplished in the present.  

This creates paths for future obstacle clearance, once one encounters an obstacle based on a required skill or set of knowledge, and minimizes disturbances to accomplishing your current goals, which will always yield the most immediately rewarding results for you, since you have prioritized them as your primary objective.

Deductive and Inductive reasoning, Boolean Logic, and Set Logic are the primary tools for doing analysis, and any troubleshooting of Systems will be significantly improved if you can break things down to terms and evaluate them for correctness against various assertions, as well as whether the assertions are valid or invalid.  

It is of critical importance that one is able to test the validity of an assertion.  Without able to validate or invalidate an assertion against it's test result, one will not know if they are making a decision based on an invalid assumption.

For example, if there was an Web Server outage for 30 minutes, and in the outage post-mortem discussion the Root Cause was suggested to be an ISP outage, as it was during the time window their ISP told them they would be doing maintenance.

Except, for this example this is not the correct cause, as an engineer got an alert on their cell phone that a service was down, they logged into the server, saw a volume had no space left on it, they deleted some old log files, and the service started working again.  Then they filed a ticket about it.

But, in this example, the person who suggested it was the ISP's fault did not read this ticket, and so was giving their best guess at what happened, based on information they had that they thought was relevant.  

If no one with better information was in that meeting, then that would be most likely selected as the primary reason for the 30 minute outage, when in actuality, the outage was caused for a different reason, and that reason was dealt with and logged according to standard work principles.

Being able to test the validity of an assertion allows us to quantify an assertion against it's subject.

If we were in the meeting we could quantify the assertion that 

This aside has already gone on quite long, but I have additional point to make on the topic of goals.

Programming a computer is done with a programming language (C, Python, Java, etc), programming your mind is done by making physical and chemical-electrical changes to your mind by learning new skills and information, which gives you a larger library of activities you can perform and problems you can solve, which gives you improved ability to accomplish your goals.

Accomplishment of your own goals, in my opinion, is a Primary Life Requirement, and should be an ever-present factor in each decision you make in your life, in order to yield yourself the best results.
{{ asside_end }}

{{ todo__recommend_critical_thinking_book }}

How do you use System Thinking?

The first thing to do is to take whatever you are thinking about, and turn it into a system.  Anything can be turned into a system, and this system can be as large or small as you need, and can contain any number of components.

Since we, as humans, are limited in the number of things we can think about simultaneously, on a conscious level especially, we need to break things into small groups of related ideas.

Let's create a system right now and do some reasoning with it, to use as an example.  We will continue to use the web server analogy, as it is one that many people will already be familiar with, and are likely to spend a lot of time dealing with in their careers, as it has become the default medium for information exchange.  You can think of this as an "Application Server" instead of web server if you like, the important thing is that it takes requests and serves back data.

In the simplest of web server systems, we have static content serving.  This is when someone has pre-created text (HTML, CSS, etc) and binary (images, videos) and the web server's job is to take requests for specific static files, and to relay those files to the requester.

Since we can create a system out of any components, let's decide what our components will be:

- A network connection to the Internet, which end-users are making requests on.
- The IP protocol for networking, and basic TCP session management, on a Linux server.
- A web server that listens on TCP port 80 on that server.
- A file system that locally contains system files.
- A file system that locally logs requests and processing.

This is a slice of components involve in web process, and just as I have arbitrarily picked these for this example, you can pick any components you want to build your own systems.  You can continue to refer to the same system over time to get more familiar with all the details of that system, as is important in operational and application documentation, or you can abandon the system as soon as it's immediate purposes are over.  Systems can be used forever or can be completely ephemeral, they are abstractions for reasoning and understanding reality, which remains too detailed and complex for us to directly understand.

Let's create an event that occurs and exercises these components, as a sequence:

- An end-user requests a file from the remote web server: http://www.domain.com/images/unstoppabletrex.png

- The request performs operations outside of this system (LAN, routing, DNS, etc), but eventually opens a TCP socket to port 80 on the web server.  The web server and the end-user now have a persistent session to communicate bidirectionally.

- The end-user requests the URL specified above (broken into URI and Host Header sections), and relays any cookie and browser header information.

- The web server accepts the input of the request, and goes through a process of routing the request internally, where it matches the domain in the Host Header value to any Host Headers it processes, and then determines if there are any directory modifications to look for the static file.

- Having determined what the path of the static file is on the local file system, if the file exists, the web server opens the file, reads it, and relays the data into the content section of the HTTP response.  After relaying the contents, it closes the file, creates a successful HTTP status code, and returns the results.  In this case we will assume that HTTP keep-alive is not enabled, and the HTTP server will close the connection afterwards.

- The web server logs the request and successful response, appending to it's access log on the local file system.

- The end-user's web browser will have received the HTTP response, getting the status code and body of the content, and in this case will display the image to the screen.

This is one way that a request event could be processed by a web server.  We can similarly model of the file does not exist, the web server may do something similar, except return a 404 File Not Found static content.

In the case of a more dynamic system, the web server could proxy the request to an application server, which then makes database calls and performs formatting logic, and then returns a dynamic result instead of a static one.

The important of systemic thinking in this is that there are no gaps.  Every connection that is required is modeled, and if new connections are required, they are added, and the remaining components need to be updated so that the system remains internally consistent.

Internal Consistency is a very important factor in any system, for it to be a properly functioning system, and will be another topic we delve into deeply.  Internal consistency has similarities to Alignment, where components are aligned with one another for maximum efficiency, but Alignment requires Internal Consistency, where something can be Internally Consistent but not aligned.  In this way Internal Consistency is a super-set of Alignment, in order to be aligned, things must be consistent, but things can be consistent and yet not well-aligned.
