### [[2.4: Systemic Thinking]]

I'll use "Systemic Thinking" to mean thinking in a way where everything is inside of a system.  It focuses on the relationships between all things in the system, and their mechanical relationships to each other.

This can be described by a network of black box functions which take inputs, emit outputs, and perform side-effects, totaling the results of anything that exists or doesn't exist.  Either way, it can be described as a system, and using this methodology for organizing one's thoughts is "systemic thinking" by my definition here.

I believe Systemic Thinking is one of the most powerful and useful tools in our mental toolbox, and could use a lot more of the educational spotlight.  In terms of yielding positive results in learning, creating things, and in performing maintenance (ex: troubleshooting), systemic thinking is one of the most useful tools.

Systemic Thinking has a number of prerequisites, such as a general understanding of how systems work, how to create systems, how to modify a system, how to inspect and evaluate the connections and links between system components, and a good basis in critical thinking.  Having the ability to think deductively and inductively is a fundamental requirement.

If you have not yet read a book on critical thinking, you should, to ensure you have down the basics of the topic.  Deductive and inductive thinking, boolean logic, and set logic are primary tools for doing analysis, and any troubleshooting of systems will be significantly improved if you can break things down to terms and evaluate them.

{{ todo__recommend_critical_thinking_book }}

How do you use System Thinking?

The first thing to do is to take whatever you are thinking about, and turn it into a system.  Anything can be turned into a system, and this system can be as large or small as you need, and can contain any number of components.

Since we, as humans, are limited in the number of things we can think about simultaneously, on a conscious level especially, we need to break things into small groups of related ideas.

Let's create a system right now and do some reasoning with it, to use as an example.  We will continue to use the web server analogy, as it is one that many people will already be familiar with, and are likely to spend a lot of time dealing with in their careers, as it has become the default medium for information exchange.  You can think of this as an "Application Server" instead of web server if you like, the important thing is that it takes requests and serves back data.

In the simplest of web server systems, we have static content serving.  This is when someone has pre-created text (HTML, CSS, etc) and binary (images, videos) and the web server's job is to take requests for specific static files, and to relay those files to the requester.

Since we can create a system out of any components, let's decide what our components will be:

- A network connection to the Internet, which end-users are making requests on.
- The IP protocol for networking, and basic TCP session management, on a Linux server.
- A web server that listens on TCP port 80 on that server.
- A file system that locally contains system files.
- A file system that locally logs requests and processing.

This is a slice of components involve in web process, and just as I have arbitrarily picked these for this example, you can pick any components you want to build your own systems.  You can continue to refer to the same system over time to get more familiar with all the details of that system, as is important in operational and application documentation, or you can abandon the system as soon as it's immediate purposes are over.  Systems can be used forever or can be completely ephemeral, they are abstractions for reasoning and understanding reality, which remains too detailed and complex for us to directly understand.

Let's create an event that occurs and exercises these components, as a sequence:

- An end-user requests a file from the remote web server: http://www.domain.com/images/unstoppabletrex.png

- The request performs operations outside of this system (LAN, routing, DNS, etc), but eventually opens a TCP socket to port 80 on the web server.  The web server and the end-user now have a persistent session to communicate bidirectionally.

- The end-user requests the URL specified above (broken into URI and Host Header sections), and relays any cookie and browser header information.

- The web server accepts the input of the request, and goes through a process of routing the request internally, where it matches the domain in the Host Header value to any Host Headers it processes, and then determines if there are any directory modifications to look for the static file.

- Having determined what the path of the static file is on the local file system, if the file exists, the web server opens the file, reads it, and relays the data into the content section of the HTTP response.  After relaying the contents, it closes the file, creates a successful HTTP status code, and returns the results.  In this case we will assume that HTTP keep-alive is not enabled, and the HTTP server will close the connection afterwards.

- The web server logs the request and successful response, appending to it's access log on the local file system.

- The end-user's web browser will have received the HTTP response, getting the status code and body of the content, and in this case will display the image to the screen.

This is one way that a request event could be processed by a web server.  We can similarly model of the file does not exist, the web server may do something similar, except return a 404 File Not Found static content.

In the case of a more dynamic system, the web server could proxy the request to an application server, which then makes database calls and performs formatting logic, and then returns a dynamic result instead of a static one.

The important of systemic thinking in this is that there are no gaps.  Every connection that is required is modeled, and if new connections are required, they are added, and the remaining components need to be updated so that the system remains internally consistent.

Internal Consistency is a very important factor in any system, for it to be a properly functioning system, and will be another topic we delve into deeply.  Internal consistency has similarities to Alignment, where components are aligned with one another for maximum efficiency, but Alignment requires Internal Consistency, where something can be Internally Consistent but not aligned.  In this way Internal Consistency is a super-set of Alignment, in order to be aligned, things must be consistent, but things can be consistent and yet not well-aligned.
